var searchIndex = {};
searchIndex["rulinalg"] = {"doc":"# The rulinalg crate.","items":[[0,"macros","rulinalg","Macros for the linear algebra modules.",null,null],[3,"AbsoluteElementwiseComparator","rulinalg::macros","The `abs` comparator used with [assert_matrix_eq!](../macro.assert_matrix_eq!.html).",null,null],[12,"tol","","The maximum absolute difference tolerated (inclusive).",0,null],[3,"ExactElementwiseComparator","","The `exact` comparator used with [assert_matrix_eq!](../macro.assert_matrix_eq!.html).",null,null],[3,"UlpElementwiseComparator","","The `ulp` comparator used with [assert_matrix_eq!](../macro.assert_matrix_eq!.html).",null,null],[12,"tol","","The maximum difference in ULP units tolerated (inclusive).",1,null],[3,"FloatElementwiseComparator","","The `float` comparator used with [assert_matrix_eq!](../macro.assert_matrix_eq!.html).",null,null],[11,"clone","","",0,null],[11,"fmt","","",0,null],[11,"eq","","",0,null],[11,"ne","","",0,null],[11,"compare","","",0,null],[11,"description","","",0,null],[11,"clone","","",2,null],[11,"fmt","","",2,null],[11,"eq","","",2,null],[11,"compare","","",2,null],[11,"description","","",2,null],[11,"clone","","",1,null],[11,"fmt","","",1,null],[11,"eq","","",1,null],[11,"ne","","",1,null],[11,"compare","","",1,null],[11,"description","","",1,null],[11,"clone","","",3,null],[11,"fmt","","",3,null],[11,"eq","","",3,null],[11,"ne","","",3,null],[11,"compare","","",3,null],[11,"description","","",3,null],[8,"ElementwiseComparator","","Trait that describes elementwise comparators for [assert_matrix_eq!](../macro.assert_matrix_eq!.html).",null,null],[10,"compare","","Compares two elements.",4,null],[10,"description","","A description of the comparator.",4,null],[0,"matrix","rulinalg","The matrix module.",null,null],[3,"PermutationMatrix","rulinalg::matrix","An efficient implementation of a permutation matrix.",null,null],[3,"Matrix","","The `Matrix` struct.",null,null],[3,"MatrixSlice","","A `MatrixSlice`",null,null],[3,"MatrixSliceMut","","A mutable `MatrixSliceMut`",null,null],[3,"Row","","Row of a matrix.",null,null],[3,"RowMut","","Mutable row of a matrix.",null,null],[3,"Rows","","Row iterator.",null,null],[3,"RowsMut","","Mutable row iterator.",null,null],[3,"Column","","Column of a matrix.",null,null],[3,"ColumnMut","","Mutable column of a matrix.",null,null],[3,"Cols","","Column iterator.",null,null],[3,"ColsMut","","Mutable column iterator.",null,null],[3,"Diagonal","","An iterator over the diagonal elements of a matrix.",null,null],[3,"DiagonalMut","","An iterator over the mutable diagonal elements of a matrix.",null,null],[3,"SliceIter","","Iterator for matrix.",null,null],[3,"SliceIterMut","","Iterator for mutable matrix.",null,null],[4,"Parity","","Parity is the fact of being even or odd.",null,null],[13,"Even","","Even parity.",5,null],[13,"Odd","","Odd parity.",5,null],[4,"Axes","","Matrix dimensions",null,null],[13,"Row","","The row axis.",6,null],[13,"Col","","The column axis.",6,null],[4,"DiagOffset","","Diagonal offset (used by Diagonal iterator).",null,null],[13,"Main","","The main diagonal of the matrix.",7,null],[13,"Above","","An offset above the main diagonal.",7,null],[13,"Below","","An offset below the main diagonal.",7,null],[0,"decomposition","","Decompositions for matrices.",null,null],[3,"PartialPivLu","rulinalg::matrix::decomposition","LU decomposition with partial pivoting.",null,null],[3,"LUP","","Result of unpacking an instance of\n[PartialPivLu](struct.PartialPivLu.html).",null,null],[12,"l","","The lower triangular matrix in the decomposition.",8,null],[12,"u","","The upper triangular matrix in the decomposition.",8,null],[12,"p","","The permutation matrix in the decomposition.",8,null],[11,"qr_decomp","rulinalg::matrix","Compute the QR decomposition of the matrix.",9,null],[11,"cholesky","","Cholesky decomposition",9,null],[11,"bidiagonal_decomp","","Converts matrix to bidiagonal form",9,null],[11,"svd","","Singular Value Decomposition",9,null],[11,"upper_hessenberg","","Returns H, where H is the upper hessenberg form.",9,null],[11,"upper_hess_decomp","","Returns (U,H), where H is the upper hessenberg form\nand U is the unitary transform matrix.",9,null],[11,"fmt","rulinalg::matrix::decomposition","",8,null],[11,"clone","","",8,null],[11,"fmt","","",10,null],[11,"clone","","",10,null],[11,"unpack","","",10,null],[11,"decompose","","Performs the decomposition.",10,{"inputs":[{"name":"matrix"}],"output":{"name":"result"}}],[11,"solve","","Solves the linear system `Ax = b`.",10,null],[11,"inverse","","Computes the inverse of the matrix which this LUP decomposition\nrepresents.",10,null],[11,"det","","Computes the determinant of the decomposed matrix.",10,null],[11,"lup_decomp","rulinalg::matrix","Computes L, U, and P for LUP decomposition.",9,null],[11,"eigenvalues","","Eigenvalues of a square matrix.",9,null],[11,"eigendecomp","","Eigendecomposition of a square matrix.",9,null],[8,"Decomposition","rulinalg::matrix::decomposition","Base trait for decompositions.",null,null],[16,"Factors","","The type representing the ordered set of factors\nthat when multiplied yields the decomposed matrix.",11,null],[10,"unpack","","Extract the individual factors from this decomposition.",11,null],[11,"rows","rulinalg::matrix","",9,null],[11,"cols","","",9,null],[11,"row_stride","","",9,null],[11,"is_empty","","",9,null],[11,"as_ptr","","",9,null],[11,"into_matrix","","",9,null],[11,"sum","","",9,null],[11,"elemul","","",9,null],[11,"elediv","","",9,null],[11,"vcat","","",9,null],[11,"rows","","",12,null],[11,"cols","","",12,null],[11,"row_stride","","",12,null],[11,"as_ptr","","",12,null],[11,"rows","","",13,null],[11,"cols","","",13,null],[11,"row_stride","","",13,null],[11,"as_ptr","","",13,null],[11,"as_mut_ptr","","Top left index of the slice.",9,null],[11,"as_mut_ptr","","Top left index of the slice.",13,null],[11,"rows","","",14,null],[11,"cols","","",14,null],[11,"row_stride","","",14,null],[11,"as_ptr","","",14,null],[11,"rows","","",15,null],[11,"cols","","",15,null],[11,"row_stride","","",15,null],[11,"as_ptr","","",15,null],[11,"as_mut_ptr","","Top left index of the slice.",15,null],[11,"rows","","",16,null],[11,"cols","","",16,null],[11,"row_stride","","",16,null],[11,"as_ptr","","",16,null],[11,"rows","","",17,null],[11,"cols","","",17,null],[11,"row_stride","","",17,null],[11,"as_ptr","","",17,null],[11,"as_mut_ptr","","Top left index of the slice.",17,null],[11,"deref","","",14,null],[11,"deref","","",15,null],[11,"deref_mut","","",15,null],[11,"deref","","",16,null],[11,"deref","","",17,null],[11,"deref_mut","","",17,null],[11,"new","","Constructor for Matrix struct.",9,{"inputs":[{"name":"usize"},{"name":"usize"},{"name":"u"}],"output":{"name":"matrix"}}],[11,"from_fn","","Constructor for Matrix struct that takes a function `f`\nand constructs a new matrix such that `A_ij = f(i, j)`,\nwhere `i` is the row index and `j` the column index.",9,{"inputs":[{"name":"usize"},{"name":"usize"},{"name":"f"}],"output":{"name":"matrix"}}],[11,"data","","Returns a non-mutable reference to the underlying data.",9,null],[11,"mut_data","","Returns a mutable slice of the underlying data.",9,null],[11,"into_vec","","Consumes the Matrix and returns the Vec of data.",9,null],[11,"zeros","","Constructs matrix of all zeros.",9,{"inputs":[{"name":"usize"},{"name":"usize"}],"output":{"name":"matrix"}}],[11,"from_diag","","Constructs matrix with given diagonal.",9,null],[11,"ones","","Constructs matrix of all ones.",9,{"inputs":[{"name":"usize"},{"name":"usize"}],"output":{"name":"matrix"}}],[11,"identity","","Constructs the identity matrix.",9,{"inputs":[{"name":"usize"}],"output":{"name":"matrix"}}],[11,"mean","","The mean of the matrix along the specified axis.",9,null],[11,"variance","","The variance of the matrix along the specified axis.",9,null],[11,"solve","","Solves the equation `Ax = y`.",9,null],[11,"inverse","","Computes the inverse of the matrix.",9,null],[11,"det","","Computes the determinant of the matrix.",9,null],[11,"fmt","","Formats the Matrix for display.",9,null],[11,"index","","",9,null],[11,"index","","",12,null],[11,"index","","",13,null],[11,"index_mut","","",13,null],[11,"index_mut","","",9,null],[11,"index","","",14,null],[11,"index","","",15,null],[11,"index_mut","","",15,null],[11,"index","","",16,null],[11,"index","","",17,null],[11,"index_mut","","",17,null],[11,"mul","","",12,null],[11,"mul","","",12,null],[11,"mul","","",13,null],[11,"mul","","",13,null],[11,"div","","",12,null],[11,"div","","",12,null],[11,"div","","",13,null],[11,"div","","",13,null],[11,"add","","",12,null],[11,"add","","",12,null],[11,"add","","",13,null],[11,"add","","",13,null],[11,"sub","","",12,null],[11,"sub","","",12,null],[11,"sub","","",13,null],[11,"sub","","",13,null],[11,"add","","",9,null],[11,"add","","",9,null],[11,"mul","","",9,null],[11,"mul","","",9,null],[11,"sub","","",9,null],[11,"sub","","",9,null],[11,"div","","",9,null],[11,"div","","",9,null],[11,"mul","","",9,null],[11,"mul","","",9,null],[11,"add","","",12,null],[11,"add","","",12,null],[11,"add","","",13,null],[11,"add","","",13,null],[11,"add","","",12,null],[11,"add","","",12,null],[11,"add","","",13,null],[11,"add","","",13,null],[11,"sub","","",12,null],[11,"sub","","",12,null],[11,"sub","","",13,null],[11,"sub","","",13,null],[11,"sub","","",12,null],[11,"sub","","",12,null],[11,"sub","","",13,null],[11,"sub","","",13,null],[11,"add","","",12,null],[11,"add","","",12,null],[11,"add","","",9,null],[11,"add","","",9,null],[11,"add","","",13,null],[11,"add","","",13,null],[11,"add","","",9,null],[11,"add","","",9,null],[11,"sub","","",12,null],[11,"sub","","",12,null],[11,"sub","","",9,null],[11,"sub","","",9,null],[11,"sub","","",13,null],[11,"sub","","",13,null],[11,"sub","","",9,null],[11,"sub","","",9,null],[11,"add","","",9,null],[11,"add","","",9,null],[11,"sub","","",9,null],[11,"sub","","",9,null],[11,"add_assign","","",9,null],[11,"add_assign","","",9,null],[11,"sub_assign","","",9,null],[11,"sub_assign","","",9,null],[11,"div_assign","","",9,null],[11,"div_assign","","",9,null],[11,"mul_assign","","",9,null],[11,"mul_assign","","",9,null],[11,"add_assign","","",13,null],[11,"add_assign","","",13,null],[11,"sub_assign","","",13,null],[11,"sub_assign","","",13,null],[11,"div_assign","","",13,null],[11,"div_assign","","",13,null],[11,"mul_assign","","",13,null],[11,"mul_assign","","",13,null],[11,"add_assign","","",9,null],[11,"add_assign","","",9,null],[11,"sub_assign","","",9,null],[11,"sub_assign","","",9,null],[11,"add_assign","","",13,null],[11,"add_assign","","",13,null],[11,"sub_assign","","",13,null],[11,"sub_assign","","",13,null],[11,"add_assign","","",13,null],[11,"add_assign","","",13,null],[11,"sub_assign","","",13,null],[11,"sub_assign","","",13,null],[11,"add_assign","","",13,null],[11,"add_assign","","",13,null],[11,"sub_assign","","",13,null],[11,"sub_assign","","",13,null],[11,"add_assign","","",9,null],[11,"add_assign","","",9,null],[11,"sub_assign","","",9,null],[11,"sub_assign","","",9,null],[11,"add_assign","","",9,null],[11,"add_assign","","",9,null],[11,"sub_assign","","",9,null],[11,"sub_assign","","",9,null],[11,"neg","","",12,null],[11,"neg","","",13,null],[11,"neg","","",9,null],[11,"next","","",18,null],[11,"next","","",19,null],[11,"next","","",20,null],[11,"last","","",20,null],[11,"nth","","",20,null],[11,"count","","",20,null],[11,"size_hint","","",20,null],[11,"next","","",21,null],[11,"last","","",21,null],[11,"nth","","",21,null],[11,"count","","",21,null],[11,"size_hint","","",21,null],[11,"next","","",22,null],[11,"last","","",22,null],[11,"nth","","",22,null],[11,"count","","",22,null],[11,"size_hint","","",22,null],[11,"next","","",23,null],[11,"last","","",23,null],[11,"nth","","",23,null],[11,"count","","",23,null],[11,"size_hint","","",23,null],[11,"next","","",24,null],[11,"last","","",24,null],[11,"nth","","",24,null],[11,"count","","",24,null],[11,"size_hint","","",24,null],[11,"next","","",25,null],[11,"last","","",25,null],[11,"nth","","",25,null],[11,"count","","",25,null],[11,"size_hint","","",25,null],[11,"from_iter","","",9,{"inputs":[{"name":"i"}],"output":{"name":"self"}}],[11,"from_iter","","",9,{"inputs":[{"name":"i"}],"output":{"name":"self"}}],[11,"from_iter","","",9,{"inputs":[{"name":"i"}],"output":{"name":"self"}}],[11,"into_iter","","",12,null],[11,"into_iter","","",13,null],[11,"mul","","",9,null],[11,"mul","","",9,null],[11,"mul","","",9,null],[11,"mul","","",9,null],[11,"mul","","",12,null],[11,"mul","","",12,null],[11,"mul","","",9,null],[11,"mul","","",9,null],[11,"mul","","",13,null],[11,"mul","","",13,null],[11,"mul","","",12,null],[11,"mul","","",12,null],[11,"mul","","",12,null],[11,"mul","","",12,null],[11,"mul","","",13,null],[11,"mul","","",13,null],[11,"mul","","",13,null],[11,"mul","","",13,null],[11,"from_matrix","","Produce a `MatrixSlice` from a `Matrix`",12,null],[11,"from_raw_parts","","Creates a `MatrixSlice` from raw parts.",12,null],[11,"from_matrix","","Produce a `MatrixSliceMut` from a mutable `Matrix`",13,null],[11,"from_raw_parts","","Creates a `MatrixSliceMut` from raw parts.",13,null],[11,"fmt","","",26,null],[11,"eq","","",26,null],[11,"ne","","",26,null],[11,"clone","","",26,null],[11,"fmt","","",5,null],[11,"clone","","",5,null],[11,"eq","","",5,null],[11,"identity","","The identity permutation.",26,{"inputs":[{"name":"usize"}],"output":{"name":"self"}}],[11,"swap_rows","","Swaps rows i and j in the permutation matrix.",26,null],[11,"inverse","","The inverse of the permutation matrix.",26,null],[11,"size","","The size of the permutation matrix.",26,null],[11,"from_array","","Constructs a `PermutationMatrix` from an array.",26,{"inputs":[{"name":"a"}],"output":{"name":"result"}}],[11,"from_array_unchecked","","Constructs a `PermutationMatrix` from an array, without checking the validity of\nthe supplied permutation.",26,{"inputs":[{"name":"a"}],"output":{"name":"permutationmatrix"}}],[11,"map_row","","Maps the given row index into the resulting row index in the permuted matrix.",26,null],[11,"parity","","Computes the parity of the permutation (even- or oddness).",26,null],[11,"as_matrix","","The permutation matrix in an equivalent full matrix representation.",26,null],[11,"det","","Computes the determinant of the permutation matrix.",26,null],[11,"permute_rows_in_place","","Permutes the rows of the given matrix in-place.",26,null],[11,"permute_cols_in_place","","Permutes the columns of the given matrix in-place.",26,null],[11,"permute_vector_in_place","","Permutes the elements of the given vector in-place.",26,null],[11,"permute_rows_into_buffer","","Permutes the rows of the given `source_matrix` and stores the\nresult in `buffer`.",26,null],[11,"permute_cols_into_buffer","","Permutes the columns of the given `source_matrix` and stores the\nresult in `buffer`.",26,null],[11,"permute_vector_into_buffer","","Permutes the elements of the given `source_vector` and stores the\nresult in `buffer`.",26,null],[11,"compose_into_buffer","","Computes the composition of `self` with the given `source_perm`\nand stores the result in `buffer`.",26,null],[11,"mul","","",26,null],[11,"mul","","",26,null],[11,"mul","","",26,null],[11,"mul","","",26,null],[11,"mul","","",26,null],[11,"mul","","",26,null],[11,"mul","","",26,null],[11,"mul","","",26,null],[11,"mul","","",9,null],[11,"mul","","",9,null],[11,"mul","","",12,null],[11,"mul","","",12,null],[11,"mul","","",13,null],[11,"mul","","",13,null],[11,"mul","","",26,null],[11,"mul","","",26,null],[8,"BaseMatrix","","Trait for immutable matrix structs.",null,null],[10,"rows","","Rows in the matrix.",27,null],[10,"cols","","Columns in the matrix.",27,null],[10,"row_stride","","Row stride in the matrix.",27,null],[11,"is_empty","","Returns true if the matrix contais no elements",27,null],[10,"as_ptr","","Top left index of the matrix.",27,null],[11,"as_slice","","Returns a `MatrixSlice` over the whole matrix.",27,null],[11,"get_unchecked","","Get a reference to a point in the matrix without bounds checking.",27,null],[11,"col","","Returns the column of a matrix at the given index.\n`None` if the index is out of bounds.",27,null],[11,"col_unchecked","","Returns the column of a matrix at the given\nindex without doing a bounds check.",27,null],[11,"row","","Returns the row of a matrix at the given index.",27,null],[11,"row_unchecked","","Returns the row of a matrix at the given index without doing unbounds checking",27,null],[11,"iter","","Returns an iterator over the matrix data.",27,null],[11,"col_iter","","Iterate over the columns of the matrix.",27,null],[11,"row_iter","","Iterate over the rows of the matrix.",27,null],[11,"diag_iter","","Iterate over diagonal entries",27,null],[11,"sum_rows","","The sum of the rows of the matrix.",27,null],[11,"sum_cols","","The sum of the columns of the matrix.",27,null],[11,"norm","","Compute given matrix norm for matrix.",27,null],[11,"metric","","Compute the metric distance between two matrices.",27,null],[11,"sum","","The sum of all elements in the matrix",27,null],[11,"min","","The min of the specified axis of the matrix.",27,null],[11,"max","","The max of the specified axis of the matrix.",27,null],[11,"into_matrix","","Convert the matrix struct into a owned Matrix.",27,null],[11,"select_rows","","Select rows from matrix",27,null],[11,"select_cols","","Select columns from matrix",27,null],[11,"elemul","","The elementwise product of two matrices.",27,null],[11,"elediv","","The elementwise division of two matrices.",27,null],[11,"select","","Select block matrix from matrix",27,null],[11,"hcat","","Horizontally concatenates two matrices. With self on the left.",27,null],[11,"vcat","","Vertically concatenates two matrices. With self on top.",27,null],[11,"diag","","Extract the diagonal of the matrix",27,null],[11,"transpose","","Tranposes the given matrix",27,null],[11,"is_diag","","Checks if matrix is diagonal.",27,null],[11,"solve_u_triangular","","Solves an upper triangular linear system.",27,null],[11,"solve_l_triangular","","Solves a lower triangular linear system.",27,null],[11,"split_at","","Split the matrix at the specified axis returning two `MatrixSlice`s.",27,null],[11,"sub_slice","","Produce a `MatrixSlice` from an existing matrix.",27,null],[8,"BaseMatrixMut","","Trait for mutable matrices.",null,null],[10,"as_mut_ptr","","Top left index of the slice.",28,null],[11,"as_mut_slice","","Returns a `MatrixSliceMut` over the whole matrix.",28,null],[11,"get_unchecked_mut","","Get a mutable reference to a point in the matrix without bounds checks.",28,null],[11,"iter_mut","","Returns a mutable iterator over the matrix.",28,null],[11,"col_mut","","Returns a mutable reference to the column of a matrix at the given index.\n`None` if the index is out of bounds.",28,null],[11,"col_unchecked_mut","","Returns a mutable reference to the column of a matrix at the given index\nwithout doing a bounds check.",28,null],[11,"row_mut","","Returns a mutable reference to the row of a matrix at the given index.\n`None` if the index is out of bounds.",28,null],[11,"row_unchecked_mut","","Returns a mutable reference to the row of a matrix at the given index\nwithout doing a bounds check.",28,null],[11,"swap_rows","","Swaps two rows in a matrix.",28,null],[11,"swap_cols","","Swaps two columns in a matrix.",28,null],[11,"col_iter_mut","","Iterate over the mutable columns of the matrix.",28,null],[11,"row_iter_mut","","Iterate over the mutable rows of the matrix.",28,null],[11,"diag_iter_mut","","Iterate over diagonal entries mutably",28,null],[11,"set_to","","Sets the underlying matrix data to the target data.",28,null],[11,"apply","","Applies a function to each element in the matrix.",28,null],[11,"split_at_mut","","Split the matrix at the specified axis returning two `MatrixSliceMut`s.",28,null],[11,"sub_slice_mut","","Produce a `MatrixSliceMut` from an existing matrix.",28,null],[11,"fmt","","",6,null],[11,"clone","","",6,null],[11,"fmt","","",9,null],[11,"clone","","",9,null],[11,"eq","","",9,null],[11,"ne","","",9,null],[11,"hash","","",9,null],[11,"fmt","","",12,null],[11,"clone","","",12,null],[11,"fmt","","",13,null],[11,"fmt","","",14,null],[11,"clone","","",14,null],[11,"fmt","","",15,null],[11,"fmt","","",24,null],[11,"fmt","","",25,null],[11,"raw_slice","","Returns the row as a slice.",14,null],[11,"raw_slice","","Returns the row as a slice.",15,null],[11,"raw_slice_mut","","Returns the row as a slice.",15,null],[11,"fmt","","",16,null],[11,"clone","","",16,null],[11,"fmt","","",17,null],[11,"fmt","","",22,null],[11,"fmt","","",23,null],[11,"fmt","","",7,null],[11,"eq","","",7,null],[11,"ne","","",7,null],[11,"fmt","","",20,null],[11,"fmt","","",21,null],[11,"fmt","","",18,null],[11,"fmt","","",19,null],[0,"convert","rulinalg","The convert module.",null,null],[11,"from","rulinalg::matrix","",9,{"inputs":[{"name":"vector"}],"output":{"name":"self"}}],[11,"from","","",9,{"inputs":[{"name":"matrixslice"}],"output":{"name":"self"}}],[11,"from","","",9,{"inputs":[{"name":"matrixslicemut"}],"output":{"name":"self"}}],[11,"from","","",7,{"inputs":[{"name":"i8"}],"output":{"name":"self"}}],[11,"from","","",7,{"inputs":[{"name":"i16"}],"output":{"name":"self"}}],[11,"from","","",7,{"inputs":[{"name":"i32"}],"output":{"name":"self"}}],[11,"from","","",7,{"inputs":[{"name":"i64"}],"output":{"name":"self"}}],[11,"from","","",7,{"inputs":[{"name":"isize"}],"output":{"name":"self"}}],[11,"try_into","","Attempts to convert the matrix into a new matrix of different scalar type.",9,null],[0,"error","rulinalg","Error handling for the linalg module.",null,null],[3,"Error","rulinalg::error","An error related to the linalg module.",null,null],[4,"ErrorKind","","Types of errors produced in the linalg module.",null,null],[13,"InvalidArg","","An argument did not uphold a necessary criteria for the function.",29,null],[13,"DecompFailure","","A failure to decompose due to some property of the data.",29,null],[13,"AlgebraFailure","","A failure due to some algebraic constraints not being met.",29,null],[13,"DivByZero","","Tried to divide by zero",29,null],[13,"ScalarConversionFailure","","Failure due to inability to convert between scalar types",29,null],[13,"InvalidPermutation","","A user-supplied permutation is not a valid permutation.",29,null],[11,"fmt","","",30,null],[11,"fmt","","",29,null],[11,"eq","","",29,null],[11,"new","","Construct a new `Error` of a particular `ErrorKind`.",30,{"inputs":[{"name":"errorkind"},{"name":"e"}],"output":{"name":"error"}}],[11,"kind","","Get the kind of this `Error`.",30,null],[11,"description","","",30,null],[11,"fmt","","",30,null],[0,"utils","rulinalg","Linear algebra utils module.",null,null],[5,"dot","rulinalg::utils","Compute dot product of two slices.",null,null],[5,"unrolled_sum","","Unrolled sum",null,null],[5,"in_place_vec_bin_op","","Vectorized binary operation applied to two slices.\nThe first argument should be a mutable slice which will\nbe modified in place to prevent new memory allocation.",null,null],[5,"vec_bin_op","","Vectorized binary operation applied to two slices.",null,null],[5,"vec_sum","","Compute vector sum of two slices.",null,null],[5,"vec_sub","","Compute vector difference two slices.",null,null],[5,"ele_mul","","Computes elementwise multiplication.",null,null],[5,"ele_div","","Computes elementwise division.",null,null],[5,"argmax","","Find argmax of slice.",null,null],[5,"argmin","","Find argmin of slice.",null,null],[5,"find","","Find index of value in slice.",null,null],[0,"vector","rulinalg","The vector module.",null,null],[3,"Vector","rulinalg::vector","The Vector struct.",null,null],[11,"index","","",31,null],[11,"index_mut","","",31,null],[11,"add","","",31,null],[11,"add","","",31,null],[11,"mul","","",31,null],[11,"mul","","",31,null],[11,"sub","","",31,null],[11,"sub","","",31,null],[11,"div","","",31,null],[11,"div","","",31,null],[11,"rem","","",31,null],[11,"rem","","",31,null],[11,"bitand","","",31,null],[11,"bitand","","",31,null],[11,"bitor","","",31,null],[11,"bitor","","",31,null],[11,"bitxor","","",31,null],[11,"bitxor","","",31,null],[11,"add","","",31,null],[11,"add","","",31,null],[11,"sub","","",31,null],[11,"sub","","",31,null],[11,"rem","","",31,null],[11,"rem","","",31,null],[11,"bitand","","",31,null],[11,"bitand","","",31,null],[11,"bitor","","",31,null],[11,"bitor","","",31,null],[11,"bitxor","","",31,null],[11,"bitxor","","",31,null],[11,"neg","","",31,null],[11,"not","","",31,null],[11,"add_assign","","",31,null],[11,"add_assign","","",31,null],[11,"sub_assign","","",31,null],[11,"sub_assign","","",31,null],[11,"div_assign","","",31,null],[11,"div_assign","","",31,null],[11,"mul_assign","","",31,null],[11,"mul_assign","","",31,null],[11,"rem_assign","","",31,null],[11,"rem_assign","","",31,null],[11,"bitand_assign","","",31,null],[11,"bitand_assign","","",31,null],[11,"bitor_assign","","",31,null],[11,"bitor_assign","","",31,null],[11,"bitxor_assign","","",31,null],[11,"bitxor_assign","","",31,null],[11,"add_assign","","",31,null],[11,"add_assign","","",31,null],[11,"sub_assign","","",31,null],[11,"sub_assign","","",31,null],[11,"rem_assign","","",31,null],[11,"rem_assign","","",31,null],[11,"bitand_assign","","",31,null],[11,"bitand_assign","","",31,null],[11,"bitor_assign","","",31,null],[11,"bitor_assign","","",31,null],[11,"bitxor_assign","","",31,null],[11,"bitxor_assign","","",31,null],[11,"new","","Constructor for Vector struct.",31,{"inputs":[{"name":"u"}],"output":{"name":"vector"}}],[11,"from_fn","","Constructor for Vector struct that takes a function `f`\nand constructs a new vector such that `V_i = f(i)`,\nwhere `i` is the index.",31,{"inputs":[{"name":"usize"},{"name":"f"}],"output":{"name":"vector"}}],[11,"size","","Returns the size of the Vector.",31,null],[11,"data","","Returns a non-mutable reference to the underlying data.",31,null],[11,"mut_data","","Returns a mutable slice of the underlying data.",31,null],[11,"into_vec","","Consumes the Vector and returns the Vec of data.",31,null],[11,"iter","","Returns an iterator over the Vector&#39;s data.",31,null],[11,"iter_mut","","Returns an iterator over mutable references to the Vector&#39;s data.",31,null],[11,"get_unchecked","","Returns a pointer to the element at the given index, without doing\nbounds checking.",31,null],[11,"get_unchecked_mut","","Returns an unsafe mutable pointer to the element at the given index,\nwithout doing bounds checking.",31,null],[11,"into","","",31,null],[11,"into_iter","","",31,null],[11,"from_iter","","",31,{"inputs":[{"name":"i"}],"output":{"name":"self"}}],[11,"fmt","","Displays the Vector.",31,null],[11,"clone","","Clones the Vector.",31,null],[11,"apply","","Applies a function to each element in the vector.",31,null],[11,"argmax","","Find the argmax of the Vector.",31,null],[11,"argmin","","Find the argmin of the Vector.",31,null],[11,"select","","Select elements from the Vector and form a new Vector from them.",31,null],[11,"zeros","","Constructs Vector of all zeros.",31,{"inputs":[{"name":"usize"}],"output":{"name":"vector"}}],[11,"ones","","Constructs Vector of all ones.",31,{"inputs":[{"name":"usize"}],"output":{"name":"vector"}}],[11,"dot","","Compute dot product with specified Vector.",31,null],[11,"sum","","The sum of the vector.",31,null],[11,"elemul","","The elementwise product of two vectors.",31,null],[11,"elediv","","The elementwise division of two vectors.",31,null],[11,"norm","","Compute vector norm for vector.",31,null],[11,"metric","","Compute metric distance between two vectors.",31,null],[11,"mean","","The mean of the vector.",31,null],[11,"variance","","The variance of the vector.",31,null],[11,"fmt","","",31,null],[11,"eq","","",31,null],[11,"ne","","",31,null],[11,"hash","","",31,null],[0,"ulp","rulinalg","Tools for ULP-based comparison of floating point numbers.",null,null],[4,"UlpComparisonResult","rulinalg::ulp","Represents the result of an ULP-based comparison between two floating point numbers.",null,null],[13,"ExactMatch","","Signifies an exact match between two floating point numbers.",32,null],[13,"Difference","","The difference in ULP between two floating point numbers.",32,null],[13,"IncompatibleSigns","","The two floating point numbers have different signs,\nand cannot be compared in a meaningful way.",32,null],[13,"Nan","","One or both of the two floating point numbers is a NaN,\nin which case the ULP comparison is not meaningful.",32,null],[8,"Ulp","","Floating point types for which two instances can be compared for Unit in the Last Place (ULP) difference.",null,null],[10,"ulp_diff","","Returns the difference between two floating point numbers, measured in ULP.",33,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"name":"ulpcomparisonresult"}}],[11,"fmt","","",32,null],[11,"clone","","",32,null],[11,"eq","","",32,null],[11,"ne","","",32,null],[0,"norm","rulinalg","The norm module",null,null],[3,"Euclidean","rulinalg::norm","The Euclidean norm",null,null],[4,"Lp","","The Lp norm",null,null],[13,"Infinity","","The L-infinity norm (supremum)",34,null],[13,"Integer","","The Lp norm where p is an integer",34,null],[13,"Float","","The Lp norm where p is a float",34,null],[8,"VectorNorm","","Trait for vector norms",null,null],[10,"norm","","Computes the vector norm.",35,null],[8,"VectorMetric","","Trait for vector metrics.",null,null],[10,"metric","","Computes the metric distance between two vectors.",36,null],[8,"MatrixNorm","","Trait for matrix norms.",null,null],[10,"norm","","Computes the matrix norm.",37,null],[8,"MatrixMetric","","Trait for matrix metrics.",null,null],[10,"metric","","Computes the metric distance between two matrices.",38,null],[11,"fmt","","",39,null],[11,"norm","","",39,null],[11,"norm","","",39,null],[11,"fmt","","",34,null],[11,"norm","","",34,null],[11,"norm","","",34,null],[0,"io","rulinalg","I/O Module",null,null],[0,"csv","rulinalg::io","CSV read / write module",null,null],[3,"Reader","rulinalg::io::csv","A CSV reader.",null,null],[3,"Writer","","A CSV writer.",null,null],[4,"Error","","An error produced by an operation on CSV data.",null,null],[13,"Encode","","An error reported by the type-based encoder.",40,null],[13,"Decode","","An error reported by the type-based decoder.",40,null],[13,"Parse","","An error reported by the CSV parser.",40,null],[13,"Io","","An error originating from reading or writing to the underlying buffer.",40,null],[13,"Index","","An error originating from using a CSV index.",40,null],[11,"read_csv","rulinalg::matrix","Read csv file as Matrix.",9,{"inputs":[{"name":"reader"}],"output":{"name":"result"}}],[11,"write_csv","","Write Matrix as csv file.",9,null],[14,"vector","rulinalg","The `vector!` macro enables easy construction of small vectors.",null,null],[14,"matrix","","The `matrix!` macro enables easy construction of small matrices.",null,null],[14,"assert_matrix_eq","","Compare matrices for exact or approximate equality.",null,null],[14,"assert_vector_eq","","Compare vectors for exact or approximate equality.",null,null],[11,"is_empty","rulinalg::matrix","Returns true if the matrix contais no elements",27,null],[11,"as_slice","","Returns a `MatrixSlice` over the whole matrix.",27,null],[11,"get_unchecked","","Get a reference to a point in the matrix without bounds checking.",27,null],[11,"col","","Returns the column of a matrix at the given index.\n`None` if the index is out of bounds.",27,null],[11,"col_unchecked","","Returns the column of a matrix at the given\nindex without doing a bounds check.",27,null],[11,"row","","Returns the row of a matrix at the given index.",27,null],[11,"row_unchecked","","Returns the row of a matrix at the given index without doing unbounds checking",27,null],[11,"iter","","Returns an iterator over the matrix data.",27,null],[11,"col_iter","","Iterate over the columns of the matrix.",27,null],[11,"row_iter","","Iterate over the rows of the matrix.",27,null],[11,"diag_iter","","Iterate over diagonal entries",27,null],[11,"sum_rows","","The sum of the rows of the matrix.",27,null],[11,"sum_cols","","The sum of the columns of the matrix.",27,null],[11,"norm","","Compute given matrix norm for matrix.",27,null],[11,"metric","","Compute the metric distance between two matrices.",27,null],[11,"sum","","The sum of all elements in the matrix",27,null],[11,"min","","The min of the specified axis of the matrix.",27,null],[11,"max","","The max of the specified axis of the matrix.",27,null],[11,"into_matrix","","Convert the matrix struct into a owned Matrix.",27,null],[11,"select_rows","","Select rows from matrix",27,null],[11,"select_cols","","Select columns from matrix",27,null],[11,"elemul","","The elementwise product of two matrices.",27,null],[11,"elediv","","The elementwise division of two matrices.",27,null],[11,"select","","Select block matrix from matrix",27,null],[11,"hcat","","Horizontally concatenates two matrices. With self on the left.",27,null],[11,"vcat","","Vertically concatenates two matrices. With self on top.",27,null],[11,"diag","","Extract the diagonal of the matrix",27,null],[11,"transpose","","Tranposes the given matrix",27,null],[11,"is_diag","","Checks if matrix is diagonal.",27,null],[11,"solve_u_triangular","","Solves an upper triangular linear system.",27,null],[11,"solve_l_triangular","","Solves a lower triangular linear system.",27,null],[11,"split_at","","Split the matrix at the specified axis returning two `MatrixSlice`s.",27,null],[11,"sub_slice","","Produce a `MatrixSlice` from an existing matrix.",27,null],[11,"as_mut_slice","","Returns a `MatrixSliceMut` over the whole matrix.",28,null],[11,"get_unchecked_mut","","Get a mutable reference to a point in the matrix without bounds checks.",28,null],[11,"iter_mut","","Returns a mutable iterator over the matrix.",28,null],[11,"col_mut","","Returns a mutable reference to the column of a matrix at the given index.\n`None` if the index is out of bounds.",28,null],[11,"col_unchecked_mut","","Returns a mutable reference to the column of a matrix at the given index\nwithout doing a bounds check.",28,null],[11,"row_mut","","Returns a mutable reference to the row of a matrix at the given index.\n`None` if the index is out of bounds.",28,null],[11,"row_unchecked_mut","","Returns a mutable reference to the row of a matrix at the given index\nwithout doing a bounds check.",28,null],[11,"swap_rows","","Swaps two rows in a matrix.",28,null],[11,"swap_cols","","Swaps two columns in a matrix.",28,null],[11,"col_iter_mut","","Iterate over the mutable columns of the matrix.",28,null],[11,"row_iter_mut","","Iterate over the mutable rows of the matrix.",28,null],[11,"diag_iter_mut","","Iterate over diagonal entries mutably",28,null],[11,"set_to","","Sets the underlying matrix data to the target data.",28,null],[11,"apply","","Applies a function to each element in the matrix.",28,null],[11,"split_at_mut","","Split the matrix at the specified axis returning two `MatrixSliceMut`s.",28,null],[11,"sub_slice_mut","","Produce a `MatrixSliceMut` from an existing matrix.",28,null],[11,"from","rulinalg::vector","",31,{"inputs":[{"name":"vec"}],"output":{"name":"self"}}],[11,"from","","",31,null],[11,"from","","",31,{"inputs":[{"name":"row"}],"output":{"name":"self"}}],[11,"from","","",31,{"inputs":[{"name":"rowmut"}],"output":{"name":"self"}}],[11,"from","","",31,{"inputs":[{"name":"column"}],"output":{"name":"self"}}],[11,"from","","",31,{"inputs":[{"name":"columnmut"}],"output":{"name":"self"}}],[11,"from_reader","rulinalg::io::csv","Creates a new CSV reader from an arbitrary `io::Read`.",41,{"inputs":[{"name":"r"}],"output":{"name":"reader"}}],[11,"from_file","","Creates a new CSV reader for the data at the file path given.",41,{"inputs":[{"name":"p"}],"output":{"name":"result"}}],[11,"from_string","","Creates a CSV reader for an in memory string buffer.",41,{"inputs":[{"name":"s"}],"output":{"name":"reader"}}],[11,"from_bytes","","Creates a CSV reader for an in memory buffer of bytes.",41,{"inputs":[{"name":"v"}],"output":{"name":"reader"}}],[11,"decode","","Uses type-based decoding to read a single record from CSV data.",41,null],[11,"records","","Returns an iterator of records in the CSV data where each field is\na `String`.",41,null],[11,"headers","","Returns a *copy* of the first record in the CSV data as strings.",41,null],[11,"delimiter","","The delimiter to use when reading CSV data.",41,null],[11,"has_headers","","Whether to treat the first row as a special header row.",41,null],[11,"flexible","","Whether to allow flexible length records when reading CSV data.",41,null],[11,"record_terminator","","Set the record terminator to use when reading CSV data.",41,null],[11,"quote","","Set the quote character to use when reading CSV data.",41,null],[11,"escape","","Set the escape character to use when reading CSV data.",41,null],[11,"double_quote","","Enable double quote escapes.",41,null],[11,"ascii","","A convenience method for reading ASCII delimited text.",41,null],[11,"byte_headers","","This is just like `headers`, except fields are `ByteString`s instead\nof `String`s.",41,null],[11,"byte_records","","This is just like `records`, except fields are `ByteString`s instead\nof `String`s.",41,null],[11,"done","","Returns `true` if the CSV parser has reached its final state. When\nthis method returns `true`, all iterators will always return `None`.",41,null],[11,"next_bytes","","An iterator over fields in the current record.",41,null],[11,"next_str","","This is just like `next_bytes` except it converts each field to\na Unicode string in place.",41,null],[11,"byte_offset","","Returns the byte offset at which the current record started.",41,null],[11,"seek","","Seeks the underlying reader to the file cursor specified.",41,null],[11,"fmt","","",40,null],[11,"description","","",40,null],[11,"cause","","",40,null],[11,"from","","",40,{"inputs":[{"name":"error"}],"output":{"name":"error"}}],[11,"fmt","","",40,null],[11,"from_file","","Creates a new `Writer` that writes CSV data to the file path given.",42,{"inputs":[{"name":"p"}],"output":{"name":"result"}}],[11,"from_writer","","Creates a new CSV writer that writes to the `io::Write` given.",42,{"inputs":[{"name":"w"}],"output":{"name":"writer"}}],[11,"from_buffer","","Creates a new CSV writer that writes to the buffer given.",42,{"inputs":[{"name":"bufwriter"}],"output":{"name":"writer"}}],[11,"from_memory","","Creates a new CSV writer that writes to an in memory buffer. At any\ntime, `as_string` or `as_bytes` can be called to retrieve the\ncumulative CSV data.",42,{"inputs":[],"output":{"name":"writer"}}],[11,"as_string","","Returns the written CSV data as a string.",42,null],[11,"as_bytes","","Returns the encoded CSV data as raw bytes.",42,null],[11,"into_string","","Convert the Writer into a string of written CSV data",42,null],[11,"into_bytes","","Convert the Writer into a vector of encoded CSV bytes.",42,null],[11,"encode","","Writes a record by encoding any `Encodable` value.",42,null],[11,"write","","Writes a record of strings (Unicode or raw bytes).",42,null],[11,"flush","","Flushes the underlying buffer.",42,null],[11,"delimiter","","The delimiter to use when writing CSV data.",42,null],[11,"flexible","","Whether to allow flexible length records when writing CSV data.",42,null],[11,"record_terminator","","Sets the record terminator to use when writing CSV data.",42,null],[11,"quote_style","","Set the quoting style to use when writing CSV data.",42,null],[11,"quote","","Set the quote character to use when writing CSV data.",42,null],[11,"escape","","Set the escape character to use when writing CSV data.",42,null],[11,"double_quote","","Set the quoting escape mechanism.",42,null]],"paths":[[3,"AbsoluteElementwiseComparator"],[3,"UlpElementwiseComparator"],[3,"ExactElementwiseComparator"],[3,"FloatElementwiseComparator"],[8,"ElementwiseComparator"],[4,"Parity"],[4,"Axes"],[4,"DiagOffset"],[3,"LUP"],[3,"Matrix"],[3,"PartialPivLu"],[8,"Decomposition"],[3,"MatrixSlice"],[3,"MatrixSliceMut"],[3,"Row"],[3,"RowMut"],[3,"Column"],[3,"ColumnMut"],[3,"SliceIter"],[3,"SliceIterMut"],[3,"Diagonal"],[3,"DiagonalMut"],[3,"Cols"],[3,"ColsMut"],[3,"Rows"],[3,"RowsMut"],[3,"PermutationMatrix"],[8,"BaseMatrix"],[8,"BaseMatrixMut"],[4,"ErrorKind"],[3,"Error"],[3,"Vector"],[4,"UlpComparisonResult"],[8,"Ulp"],[4,"Lp"],[8,"VectorNorm"],[8,"VectorMetric"],[8,"MatrixNorm"],[8,"MatrixMetric"],[3,"Euclidean"],[4,"Error"],[3,"Reader"],[3,"Writer"]]};
initSearch(searchIndex);
